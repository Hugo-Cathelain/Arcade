///////////////////////////////////////////////////////////////////////////////
// Header Guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Arcade/enums/Inputs.hpp"
#include "Arcade/interfaces/IGameModule.hpp"
#include "Arcade/utils/Color.hpp"
#include "Arcade/utils/Vec2.hpp"
#include <tuple>
#include <variant>
#include <optional>
#include <unordered_map>
#include <vector>
#include <queue>
#include <string>

///////////////////////////////////////////////////////////////////////////////
// Define the API visibility
///////////////////////////////////////////////////////////////////////////////
#ifndef API_EXPORT
    #define API_EXPORT __attribute__((visibility("default")))
#endif

///////////////////////////////////////////////////////////////////////////////
// Namespace Arc
///////////////////////////////////////////////////////////////////////////////
namespace Arc
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class API_EXPORT API
{
public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    class Event
    {
    public:
        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        enum Channel
        {
            GAME,
            GRAPHICS,
            CORE
        };

    public:
        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct KeyPressed
        {
            EKeyboardKey code;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct MousePressed
        {
            EMouseButton button;
            int x;
            int y;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct GridSize
        {
            int width;
            int height;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct BestScore
        {
            int score;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct ChangeGraphics
        {
            int delta;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct SetGraphics
        {
            std::string graphical;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct SetGame
        {
            std::string game;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct ChangeGame
        {
            int delta;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct GameOver
        {
            int score;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct Libraries
        {
            std::vector<std::string> graphicals;
            std::vector<std::string> games;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct Closed
        {};

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct PlayerInformation
        {
            std::string username;
        };

    private:
        ///////////////////////////////////////////////////////////////////////
        // Member data
        ///////////////////////////////////////////////////////////////////////
        std::variant<
            KeyPressed,
            MousePressed,
            GridSize,
            ChangeGraphics,
            ChangeGame,
            GameOver,
            Closed,
            Libraries,
            SetGraphics,
            SetGame,
            PlayerInformation,
            BestScore
        > mData;

    private:
        ///////////////////////////////////////////////////////////////////////
        /// \brief Check if a type is one of the variant types
        ///
        /// \tparam T
        /// \tparam Ts
        ///
        /// \return True if the type is one of the variant types
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T, typename... Ts>
        static constexpr bool IsOneOf(const std::variant<Ts...>*)
        {
            return (std::disjunction_v<std::is_same<T, Ts>...>);
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Check if a type is a subtype
        ///
        /// \tparam T
        ///
        /// \return True if the type is a subtype
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        static constexpr bool IsSubType = IsOneOf<T>(
            decltype(&mData)(nullptr)
        );

    public:
        ///////////////////////////////////////////////////////////////////////
        /// \brief Default constructor
        ///
        /// \tparam T
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        Event(const T& data)
        {
            static_assert(IsSubType<T>, "Invalid type");
            if constexpr (IsSubType<T>) {
                mData = data;
            }
        }

    public:
        ///////////////////////////////////////////////////////////////////////
        /// \brief Check if the event is of a specific type
        ///
        /// \tparam T
        ///
        /// \return True if the event is of the specified type
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        bool Is(void) const
        {
            static_assert(IsSubType<T>, "Invalid type");
            if constexpr (IsSubType<T>) {
                return (std::holds_alternative<T>(mData));
            }
            return (false);
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Get the event as a specific type
        ///
        /// \tparam T
        ///
        /// \return The event as the specified type
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        T* GetIf(void)
        {
            static_assert(IsSubType<T>, "Invalid type");
            if constexpr (IsSubType<T>) {
                return (std::get_if<T>(&mData));
            }
            return (nullptr);
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Get the event as a specific type
        ///
        /// \tparam T
        ///
        /// \return The event as the specified type
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        const T* GetIf(void) const
        {
            static_assert(IsSubType<T>, "Invalid type");
            if constexpr (IsSubType<T>) {
                return (std::get_if<T>(&mData));
            }
            return (nullptr);
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Construct the event as a specific type
        ///
        /// \tparam Visitor
        ///
        /// \param visitor The visitor to construct the event
        ///
        /// \return The constructed event
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename Visitor>
        decltype(auto) Visit(Visitor&& visitor)
        {
            return (std::visit(std::forward<Visitor>(visitor), mData));
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Construct the event as a specific type
        ///
        /// \tparam Visitor
        ///
        /// \param visitor The visitor to construct the event
        ///
        /// \return The constructed event
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename Visitor>
        decltype(auto) Visit(Visitor&& visitor) const
        {
            return (std::visit(std::forward<Visitor>(visitor), mData));
        }
    };

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual ~API() = default;

private:
    ///////////////////////////////////////////////////////////////////////////
    // Member data
    ///////////////////////////////////////////////////////////////////////////
    static std::unordered_map<Event::Channel, std::queue<Event>> mEvents;
    static std::queue<
        std::tuple<IGameModule::Asset, Vec2f, Color>
    > mDrawables;
    static int mGridWidth;
    static int mGridHeight;

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Poll all events one by one
    ///
    /// \return The event
    ///
    ///////////////////////////////////////////////////////////////////////////
    static std::optional<Event> PollEvent(Event::Channel channel);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Push an event to the queue
    ///
    /// \param event The event to push
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void PushEvent(Event::Channel channel, const Event& event);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Push a drawable to the queue
    ///
    /// \param drawable The drawable to push
    /// \param x
    /// \param y
    /// \param color
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void Draw(
        const IGameModule::Asset& drawable,
        Vec2f position,
        Color color = {255, 255, 255}
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Push a drawable to the queue
    ///
    /// \param drawable The drawable to push
    /// \param x
    /// \param y
    /// \param color
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void Draw(
        const IGameModule::Asset& drawable,
        Vec2i position,
        Color color = {255, 255, 255}
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param path
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void PlaySound(const std::string& path);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Pop a drawable from the queue
    ///
    /// \return The drawable
    ///
    ///////////////////////////////////////////////////////////////////////////
    static std::tuple<IGameModule::Asset, Vec2f, Color> PopDraw(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Check if the draw queue is empty
    ///
    /// \return True if the draw queue is empty
    ///
    ///////////////////////////////////////////////////////////////////////////
    static bool IsDrawQueueEmpty(void);
};

} // namespace Arc
