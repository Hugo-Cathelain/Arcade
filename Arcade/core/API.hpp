///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Arcade/enums/Inputs.hpp"
#include <variant>
#include <optional>
#include <vector>
#include <queue>

///////////////////////////////////////////////////////////////////////////////
// Define the API visibility
///////////////////////////////////////////////////////////////////////////////
#ifndef API_EXPORT
    #define API_EXPORT __attribute__((visibility("default")))
#endif

///////////////////////////////////////////////////////////////////////////////
// Namespace Arc
///////////////////////////////////////////////////////////////////////////////
namespace Arc
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class API_EXPORT API
{
public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    class Event
    {
    public:
        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct KeyPressed
        {
            EKeyboardKey key;
        };

        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        ///////////////////////////////////////////////////////////////////////
        struct MousePressed
        {
            EMouseButton button;
        };

    private:
        ///////////////////////////////////////////////////////////////////////
        // Member data
        ///////////////////////////////////////////////////////////////////////
        std::variant<KeyPressed, MousePressed> mData;

    private:
        ///////////////////////////////////////////////////////////////////////
        /// \brief Check if a type is one of the variant types
        ///
        /// \tparam T
        /// \tparam Ts
        ///
        /// \return True if the type is one of the variant types
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T, typename... Ts>
        static constexpr bool IsOneOf(const std::variant<Ts...>*)
        {
            return (std::disjunction_v<std::is_same<T, Ts>...>);
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Check if a type is a subtype
        ///
        /// \tparam T
        ///
        /// \return True if the type is a subtype
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        static constexpr bool IsSubType = IsOneOf<T>(
            decltype(&mData)(nullptr)
        );

    public:
        ///////////////////////////////////////////////////////////////////////
        /// \brief Check if the event is of a specific type
        ///
        /// \tparam T
        ///
        /// \return True if the event is of the specified type
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        bool Is(void) const
        {
            static_assert(IsSubType<T>, "Invalid type");
            if constexpr (IsSubType<T>) {
                return (std::holds_alternative<T>(mData));
            }
            return (false);
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Get the event as a specific type
        ///
        /// \tparam T
        ///
        /// \return The event as the specified type
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        T* GetIf(void)
        {
            static_assert(IsSubType<T>, "Invalid type");
            if constexpr (IsSubType<T>) {
                return (std::get_if<T>(&mData));
            }
            return (nullptr);
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Get the event as a specific type
        ///
        /// \tparam T
        ///
        /// \return The event as the specified type
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename T>
        const T* GetIf(void) const
        {
            static_assert(IsSubType<T>, "Invalid type");
            if constexpr (IsSubType<T>) {
                return (std::get_if<T>(&mData));
            }
            return (nullptr);
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Construct the event as a specific type
        ///
        /// \tparam Visitor
        ///
        /// \param visitor The visitor to construct the event
        ///
        /// \return The constructed event
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename Visitor>
        decltype(auto) Visit(Visitor&& visitor)
        {
            return (std::visit(std::forward<Visitor>(visitor), mData));
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Construct the event as a specific type
        ///
        /// \tparam Visitor
        ///
        /// \param visitor The visitor to construct the event
        ///
        /// \return The constructed event
        ///
        ///////////////////////////////////////////////////////////////////////
        template <typename Visitor>
        decltype(auto) Visit(Visitor&& visitor) const
        {
            return (std::visit(std::forward<Visitor>(visitor), mData));
        }
    };

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual ~API() = default;

private:
    ///////////////////////////////////////////////////////////////////////////
    // Member data
    ///////////////////////////////////////////////////////////////////////////
    static std::queue<Event> mEvents;

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Poll all events one by one
    ///
    /// \return The event
    ///
    ///////////////////////////////////////////////////////////////////////////
    static std::optional<Event> PollEvent(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Push an event to the queue
    ///
    /// \param event The event to push
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void PushEvent(const Event& event);
};

} // namespace Arc
