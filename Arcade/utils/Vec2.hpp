///////////////////////////////////////////////////////////////////////////////
// Header Guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Arcade/utils/Constants.hpp"
#include <iostream>
#include <exception>
#include <cmath>
#include <algorithm>

///////////////////////////////////////////////////////////////////////////////
// Namespace Arc
///////////////////////////////////////////////////////////////////////////////
namespace Arc
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
struct Vec2
{
public:
    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    union
    {
        struct { T x, y; };     //<!
        T xy[2];                //<!
    };

public:
    ///////////////////////////////////////////////////////////////////////////
    // Static properties
    ///////////////////////////////////////////////////////////////////////////
    static const Vec2<T> ZeroVector;        //<!
    static const Vec2<T> OneVector;         //<!
    static const Vec2<T> UpVector;          //<!
    static const Vec2<T> DownVector;        //<!
    static const Vec2<T> RightVector;       //<!
    static const Vec2<T> LeftVector;        //<!
    static const Vec2<T> XAxisVector;       //<!
    static const Vec2<T> YAxisVector;       //<!

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2(void) : x((T)0), y((T)0) {}

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param all
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2(T all) : x(all), y(all) {}

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param x
    /// \param y
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2(T x, T y) : x(x), y(y) {}

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam U
    ///
    /// \param other
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename U>
    Vec2(const Vec2<U>& other) : x((T)other.x), y((T)other.y) {}

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param index
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T& operator[](size_t index)
    {
        if (index >= 2)
            throw std::out_of_range("Out of range");
        return (xy[index]);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param index
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    const T& operator[](size_t index) const
    {
        if (index >= 2)
            throw std::out_of_range("Out of range");
        return (xy[index]);
    }

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param index
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T& Component(size_t index)
    {
        if (index >= 2)
            throw std::out_of_range("Out of range");
        return (xy[index]);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param index
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    const T& Component(size_t index) const
    {
        if (index >= 2)
            throw std::out_of_range("Out of range");
        return (xy[index]);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param other
    /// \param tolerance
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool Equals(const Vec2<T>& other, float tolerance = KINDA_SMALL_NUMBER)
    {
        return (
            std::abs(x - other.x) <= (T)tolerance &&
            std::abs(y - other.y) <= (T)tolerance
        );
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param x
    /// \param y
    ///
    ///////////////////////////////////////////////////////////////////////////
    void Set(const T x, const T y)
    {
        this->x = x;
        this->y = y;
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T GetMax(void) const
    {
        return (std::max(x, y));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T GetAbsMax(void) const
    {
        return (std::max(std::abs(x), std::abs(y)));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T GetMin(void) const
    {
        return (std::min(x, y));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T GetAbsMin(void) const
    {
        return (std::min(std::abs(x), std::abs(y)));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T Length(void) const
    {
        return (std::sqrt((x * x) + (y * y)));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T SquaredLength(void) const
    {
        return ((x * x) + (y * y));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param other
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T Dot(const Vec2<T>& other) const
    {
        return ((x * other.x) + (y * other.y));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param angle
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2<T> GetRotated(float angle) const
    {
        float radians = angle * (PI / 180.f);
        float sinus = std::sin(radians);
        float cosine = std::cos(radians);

        return (Vec2<T>(
            (cosine * x) - (sinus * y),
            (sinus * x) - (cosine * y)
        ));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param angle
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2<T> GetSafeNormal(float tolerance = SMALL_NUMBER) const
    {
        const T sum = SquaredLength();

        if (sum > (T)tolerance) {
            const float scale = 1.f / std::sqrt(sum);
            return (Vec2<T>((T)(x * scale), (T)(y * scale)));
        }
        return (Vec2<T>::ZeroVector);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param angle
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool Normalize(float tolerance = SMALL_NUMBER)
    {
        const T sum = SquaredLength();

        if (sum > (T)tolerance) {
            const float scale = 1.f / std::sqrt(sum);

            x *= scale;
            y *= scale;
            return (true);
        }
        x = (T)0;
        y = (T)0;
        return (false);
    }
};

///////////////////////////////////////////////////////////////////////////////
// Definition of static properties
///////////////////////////////////////////////////////////////////////////////
template <typename T> const Vec2<T> Vec2<T>::ZeroVector =   ((T) 0, (T) 0);
template <typename T> const Vec2<T> Vec2<T>::OneVector =    ((T) 1, (T) 1);
template <typename T> const Vec2<T> Vec2<T>::UpVector =     ((T) 0, (T)-1);
template <typename T> const Vec2<T> Vec2<T>::DownVector =   ((T) 0, (T) 1);
template <typename T> const Vec2<T> Vec2<T>::RightVector =  ((T) 1, (T) 0);
template <typename T> const Vec2<T> Vec2<T>::LeftVector =   ((T)-1, (T) 0);
template <typename T> const Vec2<T> Vec2<T>::XAxisVector =  ((T) 1, (T) 0);
template <typename T> const Vec2<T> Vec2<T>::YAxisVector =  ((T) 0, (T) 1);

///////////////////////////////////////////////////////////////////////////////
// Type alias
///////////////////////////////////////////////////////////////////////////////
typedef Vec2<float>         Vec2f;      //<!
typedef Vec2<int>           Vec2i;      //<!
typedef Vec2<double>        Vec2d;      //<!
typedef Vec2<unsigned int>  Vec2u;      //<!

} // namespace Arc

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator+(const Arc::Vec2<T>& lhs)
{
    return (Arc::Vec2<T>(+lhs.x, +lhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator+(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (Arc::Vec2<T>(lhs.x + rhs.x, lhs.y + rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator+(const Arc::Vec2<T>& lhs, T rhs)
{
    return (Arc::Vec2<T>(lhs.x + rhs, lhs.y + rhs));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator+(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (Arc::Vec2<T>(lhs + rhs.x, lhs + rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator+=(Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    lhs.x += rhs.x;
    lhs.y += rhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator+=(Arc::Vec2<T>& lhs, const T rhs)
{
    lhs.x += rhs;
    lhs.y += rhs;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator-(const Arc::Vec2<T>& lhs)
{
    return (Arc::Vec2<T>(-lhs.x, -lhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator-(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (Arc::Vec2<T>(lhs.x - rhs.x, lhs.y - rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator-(const Arc::Vec2<T>& lhs, T rhs)
{
    return (Arc::Vec2<T>(lhs.x - rhs, lhs.y - rhs));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator-(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (Arc::Vec2<T>(lhs - rhs.x, lhs - rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator-=(Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    lhs.x -= rhs.x;
    lhs.y -= rhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator-=(Arc::Vec2<T>& lhs, const T rhs)
{
    lhs.x -= rhs;
    lhs.y -= rhs;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator*(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (Arc::Vec2<T>(lhs.x * rhs.x, lhs.y * rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator*(const Arc::Vec2<T>& lhs, T rhs)
{
    return (Arc::Vec2<T>(lhs.x * rhs, lhs.y * rhs));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator*(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (Arc::Vec2<T>(lhs * rhs.x, lhs * rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator*=(Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    lhs.x *= rhs.x;
    lhs.y *= rhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator*=(Arc::Vec2<T>& lhs, const T rhs)
{
    lhs.x *= rhs;
    lhs.y *= rhs;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator/(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (Arc::Vec2<T>(lhs.x / rhs.x, lhs.y / rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator/(const Arc::Vec2<T>& lhs, T rhs)
{
    return (Arc::Vec2<T>(lhs.x / rhs, lhs.y / rhs));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T> operator/(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (Arc::Vec2<T>(lhs / rhs.x, lhs / rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator/=(Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    lhs.x /= rhs.x;
    lhs.y /= rhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator/=(Arc::Vec2<T>& lhs, const T rhs)
{
    lhs.x /= rhs;
    lhs.y /= rhs;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator==(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs.x == rhs.x && lhs.y == rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator==(const Arc::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x == rhs && lhs.y == rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator==(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs == rhs.x && lhs == rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator!=(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs.x != rhs.x || lhs.y != rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator!=(const Arc::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x != rhs || lhs.y != rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator!=(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs != rhs.x || lhs != rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs.x < rhs.x && lhs.y < rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<(const Arc::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x < rhs && lhs.y < rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs < rhs.x && lhs < rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<=(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs.x <= rhs.x && lhs.y <= rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<=(const Arc::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x <= rhs && lhs.y <= rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<=(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs <= rhs.x && lhs <= rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs.x > rhs.x && lhs.y > rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>(const Arc::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x > rhs && lhs.y > rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs > rhs.x && lhs > rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>=(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs.x >= rhs.x && lhs.y >= rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>=(const Arc::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x >= rhs && lhs.y >= rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>=(const T lhs, const Arc::Vec2<T>& rhs)
{
    return (lhs >= rhs.x && lhs >= rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator++(Arc::Vec2<T>& lhs)
{
    ++lhs.x;
    ++lhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator++(Arc::Vec2<T>& lhs, int)
{
    Arc::Vec2<T> temp = lhs;
    ++lhs.x;
    ++lhs.y;
    return (temp);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator--(Arc::Vec2<T>& lhs)
{
    --lhs.x;
    --lhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
Arc::Vec2<T>& operator--(Arc::Vec2<T>& lhs, int)
{
    Arc::Vec2<T> temp = lhs;
    --lhs.x;
    --lhs.y;
    return (temp);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
T operator^(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return ((lhs.x * rhs.y) - (lhs.y * rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
T operator|(const Arc::Vec2<T>& lhs, const Arc::Vec2<T>& rhs)
{
    return ((lhs.x * rhs.x) + (lhs.y * rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param os
/// \param vec
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
std::ostream& operator<<(std::ostream& os, const Arc::Vec2<T>& vec)
{
    os << '(' << vec.x << ", " << vec.y << ')';
    return (os);
}
