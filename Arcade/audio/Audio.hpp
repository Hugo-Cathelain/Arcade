///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Arcade/audio/miniaudio.h"
#include <string>
#include <thread>
#include <unordered_map>
#include <memory>
#include <mutex>
#include <atomic>

///////////////////////////////////////////////////////////////////////////////
// Namespace Arc
///////////////////////////////////////////////////////////////////////////////
namespace Arc
{

///////////////////////////////////////////////////////////////////////////////
/// \brief Audio playback system based on miniaudio
///
///////////////////////////////////////////////////////////////////////////////
class Audio
{
private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Cached audio data with reference counting
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct cached_audio
    {
        ma_decoder decoder;
        std::atomic<int> refCount;

        ///////////////////////////////////////////////////////////////////////
        /// \brief Constructor
        ///
        ///////////////////////////////////////////////////////////////////////
        cached_audio(void) : refCount(0) {}
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Audio stream representing a playing sound
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct audio_stream
    {
        ma_device device;
        ma_device_config deviceConfig;
        std::string id;
        std::atomic<int> finished;
        std::atomic<int> stop;
        std::string sourcePath;
        std::shared_ptr<cached_audio> cachedData;
        bool loop;
        float volume;
    };

private:
    ///////////////////////////////////////////////////////////////////////////
    // Static members
    ///////////////////////////////////////////////////////////////////////////
    static std::unordered_map<
        std::string, std::shared_ptr<cached_audio>
    > mAudioCache;                                      //<!
    static std::unordered_map<
        std::string, std::shared_ptr<audio_stream>
    > mAudioStreams;                                    //<!
    static std::mutex mMutex;                           //<!

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    ~Audio(void);

private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Audio data callback for miniaudio
    ///
    /// \param pDevice Pointer to the audio device
    /// \param pOutput Pointer to the output buffer
    /// \param pInput Pointer to the input buffer (unused)
    /// \param frameCount Number of frames to process
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void DataCallback(
        ma_device* pDevice,
        void* pOutput,
        const void* pInput,
        ma_uint32 frameCount
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Audio thread function
    ///
    /// \param stream Pointer to the audio stream
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void AudioThread(audio_stream* stream);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Generate a unique ID for audio streams
    ///
    /// \return Unique identifier
    ///
    ///////////////////////////////////////////////////////////////////////////
    static uint64_t GetUniqueId();

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Play an audio file
    ///
    /// \param path Path to the audio file
    /// \param id Optional identifier for the sound (auto-generated if empty)
    /// \param loop Whether to loop the audio (false by default)
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void Play(
        const std::string& path,
        const std::string& id = "",
        bool loop = false
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Stop playing a specific audio
    ///
    /// \param id Identifier of the audio to stop
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void Stop(const std::string& id);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Stop all playing audio
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void StopAll(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Release audio data from cache
    ///
    /// \param path Path to the audio file to release
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void ReleaseFromCache(const std::string& path);
};

} // namespace Arc
